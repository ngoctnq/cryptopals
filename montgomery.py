from utils import invmod_prime, sqrtmod
from ecc import EllipticCurve, EllipticPoint
from random import randrange

class MontgomeryCurve(EllipticCurve):
    def __init__(self, a, b, p, g, q, order):
        '''
        @a, b   params of the curve equation
                    by^2 = x^3 + ax^2 + x
        @p      the GF(p) to work on
        @g      the coordinates of the generator
        @q      the order of the generator
        @order  the number of elements in the finite field
                    generated by the curve on GF(p)
        '''
        self.a = a
        self.b = b
        self.p = p
        self.q = q
        self.order = order
        self.g = self.point(*g)
        self.id = self.point(1, 0)

        assert self.g.ladder(q) == 0
        assert self.g * q == self.id
    
    def point(self, x, y):
        return MontgomeryPoint(self, x, y)

    def __eq__(self, obj):
        # same config different object is different curve
        # this is to prevent recursive comparison
        return id(self) == id(obj)
    

class MontgomeryPoint(EllipticPoint):
    def __init__(self, curve, x, y):
        super().__init__(curve, x, y)

        if x != 1 or y != 0:
            assert (x ** 3 + curve.a * x * x + x) % curve.p == (curve.b * y * y) % curve.p, "Point not on the curve!"

    def _add(self, obj):
        curve, x1, y1, x2, y2 = self.curve, self.x, self.y, obj.x, obj.y
        a, b, p = curve.a, curve.b, curve.p
        x3 = b * pow(y2 - y1, 2, p) * pow(x2 - x1, p - 1 - 2, p) - a - x1 - x2
        y3 = (2 * x1 + x2 + a) * (y2 - y1) * invmod_prime(x2 - x1, p) - b * pow(y2 - y1, 3, p) * pow(x2 - x1, p - 1 - 3, p) - y1
        return MontgomeryPoint(curve, x3 % p, y3 % p)

    def _double(self):
        curve, x, y = self.curve, self.x, self.y
        a, b, p = curve.a, curve.b, curve.p
        x3 = b * pow(3 * x * x + 2 * a * x + 1, 2, p) * pow(2 * b * y, p - 1 - 2, p) - a - x - x
        y3 = (2 * x + x + a) * (3 * x * x + 2 * a * x + 1) * invmod_prime(2 * b * y, p) - b * pow(3 * x * x + 2 * a * x + 1, 3, p) * pow(2 * b * y, p - 1 - 3, p) - y
        return MontgomeryPoint(curve, x3 % p, y3 % p)

    def ladder(self, scalar) -> int:
        return _ladder(self.x, scalar, self.curve.a, self.curve.p, self.curve.order)

def _add_xz(p1: (int, int), p2: (int, int), u: int, p: int):
    # p2 - p1 = u
    u2, w2 = p1
    u3, w3 = p2
    return pow(u2 * u3 - w2 * w3, 2, p), (u * pow(u2 * w3 - w2 * u3, 2, p)) % p
    
def _double_xz(pt: (int, int), a: int, p: int):
    # assume pt on the curve y^2 = x^3 + ax^2 + x
    u2, w2 = pt
    u2u2, u2w2, w2w2 = (u2 * u2) % p, (u2 * w2) % p, (w2 * w2) % p
    return pow(u2u2 - w2w2, 2, p), (4 * u2w2 * (u2u2 + a * u2w2 + w2w2)) % p

def _ladder(u: int, k: int, a: int, p: int, q: int = None) -> int:
    # calculate u * k, with u being the first coordinate and k a scalar
    if q is not None:
        # if group order is present, then take the mod
        k %= q
    p2 = 1, 0
    p3 = u, 1
    for i in reversed(range(p.bit_length())):
        b = 1 & (k >> i)
        if b: p2, p3 = p3, p2

        p3 = _add_xz(p2, p3, u, p)
        p2 = _double_xz(p2, a, p)

        if b: p2, p3 = p3, p2
    
    return (p2[0] * invmod_prime(p2[1], p)) % p 
