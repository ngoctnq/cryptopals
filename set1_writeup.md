<sup>ƒê√¢y l√† m·ªôt b√†i trong series [C√πng gi·∫£i Cryptopals!](https://viblo.asia/s/cung-giai-cryptopals-68Z00nw9ZkG).<br>C√°c b·∫°n n√™n t·ª± l√†m ho·∫∑c v·ª´a ƒë·ªçc v·ª´a l√†m thay v√¨ ƒë·ªçc l·ªùi gi·∫£i tr·ª±c ti·∫øp.</sup>

Do ph·∫ßn n√†y kh√° ng·∫Øn n√™n m√¨nh s·∫Ω vi·∫øt to√†n b·ªô ph·∫ßn 1 trong 1 b√†i Viblo. Nh·ªØng b√†i sau l·∫±ng nh·∫±ng h∆°n s·∫Ω c√≥ th·ªÉ s·∫Ω ƒë∆∞·ª£c m√¨nh chia nh·ªè ra th√†nh nhi·ªÅu b√†i vi·∫øt.

***
**<div align="center">Kh√¥ng ch·∫ßn ch·ª´ g√¨ n·ªØa, h√£y b·∫Øt ƒë·∫ßu n√†o!</div>**
***

# [Challenge 1: Convert hex to base64](https://cryptopals.com/sets/1/challenges/1)
Kh√° ƒë∆°n gi·∫£n v·ªõi Python: ch√∫ng ta c·∫ßn ƒë·ªïi t·ª´ hex sang plaintext tr∆∞·ªõc:
```python
from binascii import unhexlify
# input: hex_
str_ = unhexlify(hex_)
```
C·∫ßn ch√∫ √Ω r·∫±ng bi·∫øn `str_` ·ªü ƒë√¢y l√† bytestring ch·ª© kh√¥ng ph·∫£i UTF-8. Ngo√†i ra, ƒë·ªÉ hi·ªÉu th√™m m·ª•c n√†y c√°c b·∫°n c√≥ th·ªÉ implement l·∫°i h√†m unhexlify l·∫°i:
```python
def unhexlify(hex_: str) -> bytes:
    # strip 0x at the beginning if needed
    hex_ = hex_.lstrip('0x')
    # zero-padding
    if len(hex_) % 2: hex_ = '0' + hex_
    bytelist = []
    for i in range(0, len(hex_), 2):
        bytelist.append(int(hex_[i * 2 : i * 2 + 2], 16))
    return bytes(bytelist)
```
V·ªÅ c∆° b·∫£n, m·ªói s·ªë (1 byte/2 hexdigits) trong hexstring ƒë√≥ s·∫Ω t∆∞∆°ng ·ª©ng v·ªõi m·ªôt ch·ªØ c√°i. Ch√∫ √Ω: h√†m n√†y s·∫Ω ch·ªâ nh·∫≠n ƒë·∫ßu v√†o l√† string th∆∞·ªùng, trong khi `binascii.unhexlify` nh·∫≠n c·ªßa string th∆∞·ªùng l·∫´n bytestring.

R·ªìi ƒë·ªïi t·ª´ string qua base64: m·ª•c n√†y l·∫±ng nh·∫±ng n√™n m√¨nh s·∫Ω kh√¥ng implement tay ƒë√¢u üòÖ
```python
from base64 import b64encode
b64_ = b64encode(str_)
```

Gh√©p t·∫•t c·∫£ l·∫°i v·ªõi nhau, ta c√≥:
```python
from binascii import unhexlify
from base64 import b64encode
def hex2b64(hex_: hex) -> bytes:
    return b64encode(unhexlify(hex_))
```

C√°c b·∫°n h√£y t·ª± test tay v√≠ d·ª• tr√™n trang ƒë√≥ ƒë·ªÉ check nh√©! 

**Easter egg:** By the way, test string ƒë√≥ sau khi decode t·ª´ hex v·ªÅ string s·∫Ω ra
```
b"I'm killing your brain like a poisonous mushroom"
```
l√† m·ªôt c√¢u trong b√†i h√°t [Ice Ice Baby c·ªßa Vanilla Ice](https://www.youtube.com/watch?v=rog8ou-ZepE). Trong set n√†y s·∫Ω c√≥ r·∫•t nhi·ªÅu references nh∆∞ v·∫≠y, n√™n h√£y ƒë·ªÉ √Ω :D

# [Challenge 2: Fixed XOR](https://cryptopals.com/sets/1/challenges/2)
Cho 2 chu·ªói hex c√≥ ƒë·ªô d√†i b·∫±ng nhau, c·∫ßn XOR ch√∫ng ra chu·ªói hex k·∫øt qu·∫£. Th·ª© t·ª± c√°c b∆∞·ªõc s·∫Ω nh∆∞ sau:
- Vi·ªác ƒë·∫ßu ti√™n l√† ƒë·ªïi c·∫£ 2 chu·ªói hex ra c√°c bytes ƒë·ªÉ ch√∫ng ta c√≥ th·ªÉ XOR:
```python
from binascii import unhexlify
# input: hex1, hex2
hex1 = unhexlify(hex1)
hex2 = unhexlify(hex2)
```
- Sau ƒë√≥, ch√∫ng ta XOR t·ª´ng c·∫∑p byte:
```python
bytelist = []
for i in range(len(hex1)):
    bytelist.append(hex1[i] ^ hex2[i])
bytelist = bytes(bytelist)
```
- V√† cu·ªëi c√πng, ch√∫ng ta chuy·ªÉn h·∫øt l·∫°i v·ªÅ d·∫°ng hex:
```python
from binascii import hexlify
xored = hexlify(bytelist)
```
Gh√©p h·∫øt t·∫•t c·∫£ v√†o k√®m v·ªõi vi·∫øt t·∫Øt b·∫±ng c√°ch x·ª≠ l√Ω ki·ªÉu functional, ta c√≥:
```python
from binascii import hexlify, unhexlify
def hex_xor(hex1: hex, hex2: hex) -> hex:
    return hexlify(bytes(x ^ y for x, y in zip(unhexlify(hex1), unhexlify(hex2))))
```
B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng `map` thay v√¨ list comprehension, nh∆∞ng code s·∫Ω b·ªã d√†i ra ch√∫t. H√£y th·ª≠ xem!

**Easter egg:** hexstring th·ª© 2 s·∫Ω decode ra
```
b"hit the bull's eye"
```
v√† k·∫øt qu·∫£ cu·ªëi c√πng decode ra
```
b"the kid don't play"
```
ƒê√¢y l√† m·ªôt c√¢u kh√°c trong l·ªùi b√†i h√°t Ice Ice Baby; tuy nhi√™n c√≥ h∆°i sai m·ªôt ch√∫t, l·ªùi ƒë√∫ng c·ªßa b√†i h√°t l√†
> You better hit bull's eye, the kid don't play

S·ª± sai l·ªách n√†y ch·∫Øc l√† v√¨ t√°c gi·∫£ ph·∫£i s·ª≠a sao cho 2 chu·ªói n√†y c√≥ c√πng ƒë·ªô d√†i :D

# [Challenge 3: Single-byte XOR cipher](https://cryptopals.com/sets/1/challenges/3)
Vi·ªác ƒë·∫ßu ti√™n l√† ch√∫ng ta c·∫ßn ph·∫£i t·∫°o ra m·ªôt stream XOR tr∆∞·ªõc :D Sau ƒë√≥, ch√∫ng ta c√≥ th·ªÉ bruteforce xem key l√† g√¨ sau.  H∆°i nh·∫£y tr∆∞·ªõc √°nh ƒë√®n √¥ t√¥ t√≠, nh∆∞ng v·ªÅ c∆° b·∫£n th√¨ ƒë√¢y l√† stream cipher, khi key c·ªßa b·∫°n ƒë∆∞·ª£c l·∫∑p l·∫°i li√™n t·ª•c cho ƒë·∫øn khi ƒë·ªß ƒë·ªô d√†i c·ªßa string c·∫ßn m√£ ho√°. V√¨ v·∫≠y, ch√∫ng ta ch·ªâ c·∫ßn s·ª≠ d·ª•ng fixed XOR v·ªõi key ƒë√£ ƒë∆∞·ª£c l·∫∑p l·∫°i:
```python
from binascii import hexlify, unhexlify
from itertools import cycle
def hex_xor(hex1: hex, hex2: hex) -> hex:
    # will repeat hex2 (the key) if needed.
    return hexlify(bytes(x ^ y for x, y in zip(unhexlify(hex1), cycle(unhexlify(hex2)))))
```

Th·∫≠m ch√≠, c√°c b·∫°n c√≥ th·ªÉ ƒë·ªÉ √Ω r·∫±ng th·ª±c ra fixed XOR c≈©ng ch·ªâ l√† m·ªôt phi√™n b·∫£n ƒë·∫∑c bi·ªát c·ªßa streaming XOR! N√™n, t·ª´ b√¢y gi·ªù ch√∫ng ta c√≥ th·ªÉ t·∫°m b·ªè qua n√≥ v√† ch·ªâ d√πng streaming XOR th√¥i.

Sau ƒë√≥, ch√∫ng ta s·∫Ω nghƒ© ngay ƒë·∫øn vi·ªác th·ª≠ t·∫•t c·∫£ c√°c key xem c√≥ b·∫£n ƒë√£ gi·∫£i m√£ n√†o m√† kh√¥ng c√≥ k√Ω t·ª± l·∫° n√†o l√† ƒë∆∞·ª£c. Code th√¨ d·ªÖ th√¥i:

```python
from string import printable
# input: cipher
def is_printable(hex_: hex) -> bool:
    return len(set(unhexlify(s)) - set(printable.encode())) == 0

for key in printable:
    decrypted = hex_xor(cipher, hexlify(key.encode()))
    if is_printable(decrypted):
        print(key, unhexlify(decrypted))
```

Tuy nhi√™n, ph∆∞∆°ng ph√°p tr·∫ª con ƒë√≥ cho ch√∫ng ta nhi·ªÅu h∆°n 1 ƒë√°p √°n! V√¨ v·∫≠y, ch√∫ng ta s·∫Ω ph·∫£i s·ª≠ d·ª•ng m·ªôt k·ªπ thu·∫≠t x·ªãn h∆°n, ƒë√≥ l√† **frequency analysis**. V·ªÅ c∆° b·∫£n, ta s·∫Ω th·ª≠ t·∫•t c·∫£ c√°c key c√≥ th·ªÉ (th·ª≠ v·ªõi t·∫•t c·∫£ c√°c ch·ªØ c√°i, nh∆∞ hint c·ªßa b√†i cho bi·∫øt). Sau ƒë√≥, v·ªõi m·ªói m·ªôt chu·ªói ƒë∆∞a ra, ch√∫ng ta c·∫ßn check xem t·∫ßn s·ªë c√°c ch·ªØ c√°i c√≥ gi·ªëng v·ªõi ti·∫øng Anh kh√¥ng. Ng√†y x∆∞a l√∫c m√¨nh c√≤n b√©, m√¨nh ch·ªâ check xem top 6 ch·ªØ c√°i hay xu·∫•t hi·ªán nh·∫•t c√≥ ph·∫£i l√† `etaoin` kh√¥ng. Tuy nhi√™n, b√¢y gi·ªù ƒë√£ l√† d√¢n giang h·ªì AI, ch√∫ng ta ph·∫£i s·ª≠ d·ª•ng m·ªôt metrics c·ª• th·ªÉ: v·ªõi 2 ph√¢n b·ªë, ch√∫ng ta c√≥ th·ªÉ t√¨m ra ƒë∆∞·ª£c ƒë·ªô kh√°c nhau c·ªßa ch√∫ng. M·ªôt trong c√°c l·ª±a ch·ªçn metrics ƒë√≥ l√† [log likelihood](https://en.wikipedia.org/wiki/Cross_entropy#Relation_to_log-likelihood):

$$
\mathcal{L}_\mathbf{p}(\mathbf{p'})=\sum_c\mathbf{p}(c)\log\mathbf{p'}(c)
$$

v·ªõi $c$ l√† c√°c ch·ªØ c√°i trong b·∫£ng ch·ªØ c√°i.

```python
# from http://practicalcryptography.com/cryptanalysis/letter-frequencies-various-languages/english-letter-frequencies/
ENGLISH_FREQ = {
    'A' :  8.55,    'K' :  0.81,    'U' :  2.68,
    'B' :  1.60,    'L' :  4.21,    'V' :  1.06,
    'C' :  3.16,    'M' :  2.53,    'W' :  1.83,
    'D' :  3.87,    'N' :  7.17,    'X' :  0.19,
    'E' : 12.10,    'O' :  7.47,    'Y' :  1.72,
    'F' :  2.18,    'P' :  2.07,    'Z' :  0.11,
    'G' :  2.09,    'Q' :  0.10,                 
    'H' :  4.96,    'R' :  6.33,                 
    'I' :  7.33,    'S' :  6.73,                 
    'J' :  0.22,    'T' :  8.94,    
}

def get_score(s: bytes,
              replace: bool = True,
              puncts: Iterable[bytes] = b',. \'"\n'
             ) -> float:
    '''
    Get the log likelihood of an English string.
    Parameters:
    @s          bytestring to be considered
    @replace    whether to not count valid punctuations in freq analysis
    @puncts     the punctuations to consider
                only required when `replace` is True

    Effectively, remove punctuations from the strings, so that the normalizing
    constant is smaller in that case, prioritizing strings with more printables.
    '''
    if replace:
        for b in puncts:
            if type(b) is int:
                b = chr(b).encode()
            s = s.replace(b, b'')
    return sum(ENGLISH_FREQ[char] * (log(s.count(char.encode()) + s.count(char.lower().encode()) + 1e-12) - log(len(s))) \
        for char in ENGLISH_FREQ)
```
N·∫øu b·∫°n ƒë·ªÉ √Ω th√¨ h√†m `get_score` c√≥ m·ªôt ƒë·∫ßu v√†o l·∫°i l√† `replace`: C·ª• th·ªÉ l√† khi `replace=True`, decrypt candidate c·ªßa ch√∫ng ta s·∫Ω kh√¥ng t√≠nh c√°c ch·ªØ c√°i th∆∞·ªùng xu·∫•t hi·ªán trong ƒëo·∫°n vƒÉn ti·∫øng Anh (ch·∫•m ph·∫©y, d·∫•u c√°ch, v.v...), t·ª´ ƒë√≥ s·∫Ω l√†m gi·∫£m ƒë·ªô d√†i c·ªßa string v√† tƒÉng probability c·ªßa $\mathbf{p'}$ v·ªÅ g·∫ßn h∆°n $\mathbf{p}$. Nh∆∞ m·ªôt h·ªá qu·∫£, khi so s√°nh c√°c chu·ªói c√≥ c√°c ch·ªØ c√°i trong b·∫£ng ch·ªØ c√°i gi·ªëng nhau, th√¨ chu·ªói n√†o c√≥ √≠t c√°c k√Ω t·ª± r√°c h∆°n s·∫Ω c√≥ ƒëi·ªÉm cao h∆°n.

Sau ƒë√≥, ch√∫ng ta so s√°nh c√°c likelihood c·ªßa c√°c chu·ªói ƒë√£ gi·∫£i m√£ gi·ªëng v·ªõi ph√¢n b·ªë chu·∫©n c·ªßa ti·∫øng Anh, v√† l·∫•y chu·ªói n√†o c√≥ gi√° tr·ªã l·ªõn nh·∫•t th√¥i. Trong code tr√™n c·ªßa m√¨nh c√≥ th√™m $10^{-12}$ v√†o c√°c gi√° tr·ªã t·∫ßn s·ªë kh√¥ng t·ªìn t·∫°i ($p'=0$) ƒë·ªÉ tr√°nh numerical instability, v√¨ $\log 0 = -\infty$ s·∫Ω ra c√°c k·∫øt qu·∫£ toang. C√°c b·∫°n h√£y t·ª± vi·∫øt c√¥ng th·ª©c ra ƒë·ªÉ t√¨m hi·ªÉu t·∫°i sao code m√¨nh ƒë√∫ng nh√© (^^;)

```python
# rewrite to work with bytes instead of hex
def stream_xor(b1: bytes, b2: bytes) -> bytes:
    return bytes(x ^ y for x, y in zip(b1, cycle(b2)))

def brute_xor(cipher: bytes,
              c_min: int = 1,
              c_max: int = 4,
              charset: Iterable[bytes] = printable.encode()
             ) -> (bytes, bytes):
    '''
    Parameters:
        @cipher     cipher to be decrypted
        @c_min      the min length of XOR key
        @c_max      the max length of XOR key
        @charset    the character set of the key
    Output:
        @max_score  the maximum likelihood
        @key        the key used to decrypt
        @decrypted  the decrypted text
    Note: this function runs sequentially.
    Should be easily modified to run in parallel.
    '''
    max_score, max_decrypted, max_key = None, None, None
    for c_len in range(c_min, c_max + 1):
        for key in product(charset, repeat=c_len):
            # broken bytestring
            if type(key[0]) is int:
                key = bytes(key)
            # literal list of bytes
            # helpful when you're trying only a fixed set of possible keys
            else:
                key = b''.join(key)
            decrypted = stream_xor(cipher, key)
            score = get_score(decrypted)
            if max_score is None or score > max_score:
                max_score, max_decrypted, max_key = score, decrypted, key
    return max_score, max_key, max_decrypted
```

N·∫øu kh√¥ng s·ª≠ d·ª•ng normalizing constant (v·ªõi `replace` trong h√†m `get_score`), d√πng ph∆∞∆°ng ph√°p n√†y ra m·ªôt k·∫øt qu·∫£ kh√° l√† ƒë√°ng s·ª£:
```
b'cOOKING\x00mc\x07S\x00LIKE\x00A\x00POUND\x00OF\x00BACON'
```
v·ªõi key `x`. Tuy nhi√™n, v·ªõi c√°c ch·ªØ c√°i b·ªã ng∆∞·ª£c case nh∆∞ th·∫ø n√†y nghƒ©a l√† casing bit ƒë√£ b·ªã ng∆∞·ª£c, v·∫≠y ch√∫ng ta ƒë·ªïi case key (th√†nh `X`) l√† s·∫Ω ra ƒë∆∞·ª£c ƒë√°p √°n. N·∫øu ch√∫ng ta ƒë·ªÉ `replace=True` th√¨ ƒë√°p √°n ƒë√∫ng s·∫Ω xu·∫•t hi·ªán.

**Easter egg:** ƒë√°p √°n c·ªßa b√†i n√†y l√†
```
b"Cooking MC's like a pound of bacon"
```
c≈©ng l√† lyrics c·ªßa Ice Ice Baby.

# [Challenge 4: Detect single-character XOR](https://cryptopals.com/sets/1/challenges/4)

V·ªõi code ph·∫ßn 3 th√¨ c√¢u n√†y l·∫°i ch·∫£ qu√° d·ªÖ r·ªìi.
```python
import requests
content = requests.get('https://cryptopals.com/static/challenge-data/4.txt').text
print(max([brute_xor(unhexlify(line), c_max=1) for line in content.split('\n')]))
```

**Easter egg:** ƒê√°p √°n l·∫ßn n√†y c≈©ng l√† lyrics (ch·∫Øc kh√¥ng ph·∫£i nh·∫Øc l·∫°i ƒë√¢u nh·ªâ...)
```
b'Now that the party is jumping\n'
```

# [Challenge 5: Implement repeating-key XOR](https://cryptopals.com/sets/1/challenges/5)

Th·ª±c ra m√¨nh ƒë√£ code c√°i n√†y t·ª´ tr√™n, v√¨ bi·∫øt tr∆∞·ªõc c√°i n√†y s·∫Ω b·ªã h·ªèi n√™n ƒë√£ nh·∫£y tr∆∞·ªõc ƒë·∫ßu √¥ t√¥ :D

*Ch√∫ √Ω:* c√°c block trong ƒë·ªÅ b√†i ƒë·ªÅu l√† li·ªÅn nhau. Plaintext block l√† 2 d√≤ng nh∆∞ng encrypt trong c√πng m·ªôt l·∫ßn, c√°ch nhau b·ªüi newline (`\n`). Cipher block l√† 1 d√≤ng hex, ch·∫≥ng qua d√†i qu√° n√™n b·ªã chia ƒë√¥i th√†nh 2.

**Easter egg:** 2 c√¢u c·∫ßn encrypt ch√≠nh l√† lyrics
```
Burning 'em, if you ain't quick and nimble
I go crazy when I hear a cymbal
```
v√† key `ICE` l√† nickname c·ªßa ca sƒ© (Vanilla Ice), l√Ω do t·∫°i sao t√™n b√†i c√≥ t√™n nh∆∞ v·∫≠y.

***
**<div align="center">V√† cu·ªôc vui gi·ªù m·ªõi ch·ªâ b·∫Øt ƒë·∫ßu.</div>**
***

# [Challenge 6: Break repeating-key XOR](https://cryptopals.com/sets/1/challenges/6)

Nh∆∞ ƒë√£ ƒë∆∞·ª£c hint, vi·ªác ƒë·∫ßu ti√™n ch√∫ng ta c·∫ßn l√†m l√† implement Hamming distance cho 2 string. Do kh√¥ng qu√° kh√≥ n√™n m√¨nh ch·ªâ ƒë∆∞a ra l·ªùi gi·∫£i th√¥i.

*Ch√∫ √Ω:* Hamming distance ·ªü ƒë√¢y ƒë∆∞·ª£c t√≠nh theo **bit** ch·ª© kh√¥ng ph·∫£i **byte**! L·∫ßn ƒë·∫ßu m√¨nh l√†m set n√†y c≈©ng b·ªã nh·∫ßm nh∆∞ v·∫≠y.

```python
def hamming(str1: bytes, str2: bytes) -> int:
    assert len(str1) == len(str2)
    diff = 0
    for x, y in zip(str1, str2):
        # in case this is an array of bytes instead of a bytestring
        if type(x) is not int:
            x = ord(x)
        if type(y) is not int:
            y = ord(y)
        diff += sum(map(int, bin(x ^ y)[2:]))
    return diff

assert hamming(b'this is a test', b'wokka wokka!!!') == 37
```

Sau ƒë√≥, ch√∫ng ta s·ª≠ d·ª•ng Hamming distance ƒë·ªÉ ƒëo√°n ƒë·ªô d√†i c·ªßa key. ƒê√¢y l√† m·ª•c 1-4 c·ªßa h∆∞·ªõng d·∫´n c√¢u ƒë√≥.
```python
def break_repeated_xor(cipher: bytes,
                       min_keysize=2,
                       max_keysize=40,
                      ) -> (bytes, bytes):
    '''
    Returns:
    @key        the guessed key
    @decrypted  the decrypted text with that key
    '''
    min_distance, _min_keysize = None, None
    for keysize in range(min_keysize, max_keysize + 1):
        # we take (max) 4 blocks and get the one with minimum average edit distance
        block_count = min(len(cipher) // keysize, 4)
        blocks = []
        for i in range(block_count):
            blocks.append(cipher[i * keysize : (i + 1) * keysize])
        distance = 0
        for i in range(block_count):
            for j in range(i, block_count):
                distance += hamming(blocks[i], blocks[j])
        distance /= (keysize * block_count * (block_count - 1) / 2)
        if min_distance is None or min_distance > distance:
            min_distance, _min_keysize = distance, keysize
```

V√† ph·∫ßn c√≤n l·∫°i l√† ƒëo√°n t·ª´ng ch·ªØ c√°i m·ªôt c·ªßa key:
```python
    key = b''
    for i in range(_min_keysize):
        _, keychar, _ = brute_xor(cipher[i::_min_keysize], c_max=1)
        key += keychar
    
    return key, stream_xor(cipher, key)
```

R·ªìi ch√∫ng ta ch·∫°y v√† in ra ƒë√°p √°n th√¥i.
```python
import requests
content = requests.get('https://cryptopals.com/static/challenge-data/6.txt').text
content = b64decode(content)
print(break_repeated_xor(content))
```

**Easter egg:** Key c·ªßa b√†i n√†y l√†
```
b'Terminator X: Bring the noise'
```
"[Bring The Noise](https://www.youtube.com/watch?v=l_Jeyif7bB4)" l√† t√™n m·ªôt b√†i h√°t c·ªßa nh√≥m nh·∫°c Public Enemy, trong ƒë√≥ [Terminator X](https://en.wikipedia.org/wiki/Terminator_X) l√† DJ c·ªßa nh√≥m hip-hop ƒë√≥.

V√†, plaintext c·ªßa b√†i ƒë√≥ l√† to√†n b·ªô lyrics c·ªßa b√†i ["Play That Funky Music" c·ªßa Vanilla Ice](https://www.youtube.com/watch?v=zNJ8_Dh3Onk) ‚Äî do r·∫•t d√†i n√™n m√¨nh s·∫Ω kh√¥ng copy l·∫°i.

# [Challenge 7: AES in ECB mode](https://cryptopals.com/sets/1/challenges/7)

Do ECB s·ª≠ d·ª•ng l·∫°i encryptor/decryptor m√† kh√¥ng c√≥ IV (hay IV to√†n null bytes, n√™n ch√∫ng ta c√≥ th·ªÉ kh·ªüi ƒë·∫ßu tr∆∞·ªõc):

```python
import requests
content = requests.get('https://cryptopals.com/static/challenge-data/7.txt').text
cryptor = AES.new(b'YELLOW SUBMARINE', AES.MODE_ECB)
```
M√¨nh kh√¥ng implement l·∫°i AES v√¨:
- Qu√° kh√≥ hi·ªÉu :( M√¨nh k·ªá n√≥ lu√¥n nh∆∞ h·ªôp ƒëen.
- AES ƒë∆∞·ª£c coi l√† an to√†n, c√≥ nghƒ©a l√† s·∫Ω kh√¥ng c√≥ exploit n√†o ph√° ƒë∆∞·ª£c n√≥.

B√¢y gi·ªù mu·ªën gi·∫£i d·ªÖ nh·∫•t th√¨ d√πng h√†m c·ªßa PyCryptodome l√† xong:
```python
print(cryptor.decrypt(b64decode(content)))
```

Ho·∫∑c ƒë·ªÉ th·ª≠ cho ch·∫Øc k√®o th√¨ do ECB encrypt t·ª´ng block m·ªôt, ch√∫ng ta chia nh·ªè file encrypted th√†nh t·ª´ng block r·ªìi decrypt d·∫ßn:
```python
decrypted = b''
for line in content.split('\n'):
    decrypted += cryptor.decrypt(b64decode(content))
print(decrypted)
```
K·∫øt qu·∫£ s·∫Ω ra gi·ªëng nhau th√¥i :)

**Easter egg:** Plaintext c·ªßa b√†i n√†y c≈©ng l√† to√†n b·ªô lyrics c·ªßa b√†i Play That Funky Music. Ngo√†i ra, ngo√†i l√Ω do ƒë·ªÉ key d√†i ƒë√∫ng 16 ch·ªØ c√°i, [Yellow Submarine](https://www.youtube.com/watch?v=m2uTFF_3MaA) l√† t√™n m·ªôt b√†i h√°t c·ªßa The Beatles.

# [Challenge 8: Detect AES in ECB mode](https://cryptopals.com/sets/1/challenges/8)

ƒê·ªÅ b√†i ƒë√£ hint m·ªôt c√°ch l·ªô li·ªÖu r·∫±ng ECB s·∫Ω cho ciphertext gi·ªëng nhau cho c√°c plaintext block gi·ªëng nhau. V·ªõi m·ªói d√≤ng trong file ƒë√≥, ch√∫ng ta chia nh·ªè th√†nh t·ª´ng block 16 bytes, v√† xem c√≥ d√≤ng n√†o c√≥ block n√†o l·∫∑p l·∫°i nhi·ªÅu h∆°n 1 l·∫ßn kh√¥ng.

```python
import requests
content = requests.get('https://cryptopals.com/static/challenge-data/8.txt').text.strip().split('\n')
max_freq, max_cipher = None, None

from collections import Counter
for line in content:
    line = unhexlify(line)
    blocks = []
    for i in range(0, len(line), 16):
        blocks.append(line[i : i + 16])
    max_ = max(Counter(blocks).values())
    if max_freq is None or max_freq < max_:
        max_freq, max_cipher = max_, line
print(max_freq, max_cipher)
```

N·∫øu b·∫°n in h·∫øt ra ƒë·ªÉ nh√¨n s·∫Ω th·∫•y c√≥ ƒë√∫ng 1 d√≤ng c√≥ 1 block l·∫∑p l·∫°i 4 l·∫ßn, v√† code c·ªßa ch√∫ng ta s·∫Ω cho ƒë√∫ng d√≤ng ƒë√≥. R·∫•t ti·∫øc m√¨nh kh√¥ng t√¨m ra key v√† plaintext c·ªßa b√†i n√†y :(

***
**<div align="center">H·∫øt r·ªìi ƒë√≥.</div>**
***