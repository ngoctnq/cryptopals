from rsa import invmod, invmod_prime
from random import randrange

class WeierstrassCurve:
    def __init__(self, a, b, p, g, q, order):
        '''
        @a, b   params of the curve equation
                    y^2 = x^3 + ax + b
        @p      the GF(p) to work on
        @g      the coordinates of the generator
        @q      the order of the generator
        @order  the number of elements in the finite field
                    generated by the curve on GF(p)
        '''
        self.a = a
        self.b = b
        self.p = p
        self.q = q
        self.order = order
        self.g = self.point(*g)
        self.id = self.point(0, 1)

        assert self.g * q == self.id
    
    def point(self, x, y):
        return WeierstrassPoint(self, x, y)

    def __eq__(self, obj):
        # same config different object is different curve
        # this is to prevent recursive comparison
        return id(self) == id(obj)

    def get_eqn(self):
        ret = 'x^3'
        if self.a > 0:
            ret += f' + {self.a}x'
        elif self.a < 0:
            ret += f' - {-self.a}x'
        if self.b > 0:
            ret += f' + {self.b}'
        elif self.b < 0:
            ret += f' - {-self.b}'
        return ret

    def generate_keypair(self):
        private = randrange(0, self.q)
        public = self.g * private
        return private, public

class WeierstrassPoint:
    def __init__(self, curve, x, y):
        self.curve = curve
        self.x = x
        self.y = y

        # make sure the point is valid
        if x != 0 or y != 1:
            assert (pow(x, 3, curve.p) + curve.a * x + curve.b) % curve.p == pow(y, 2, curve.p), "Point not on the curve!"

    def __str__(self):
        return f'{(self.x, self.y) if self != self.curve.id else "Identity"}' + \
               f' of {self.curve.get_eqn()}'
    
    __repr__ = __str__

    def copy(self):
        # shallow copy
        return WeierstrassPoint(self.curve, self.x, self.y)

    def __neg__(self):
        return WeierstrassPoint(self.curve, self.x, self.curve.p - self.y)

    def __eq__(self, obj):
        return self.curve == obj.curve and self.x == obj.x and self.y == obj.y

    def __add__(self, obj):
        assert isinstance(self, WeierstrassPoint) and isinstance(obj, WeierstrassPoint), \
                'Can only add Point with another Point.'
        assert self.curve == obj.curve, 'Points must be of the same curve.'
        
        curve = self.curve
        if self == curve.id:
            return obj
        if obj == curve.id:
            return self
        if self == -obj:
            return curve.id

        if self == obj:
            m = ((3 * self.x * self.x + curve.a) * invmod(2 * self.y, curve.p)) % curve.p
        else:
            m = ((obj.y - self.y) * invmod(obj.x - self.x, curve.p)) % curve.p
        
        new_x = (m * m - self.x - obj.x) % curve.p
        new_y = (m * (self.x - new_x) - self.y) % curve.p
        
        return WeierstrassPoint(curve, new_x, new_y)

    def __mul__(self, scalar):
        assert isinstance(self, WeierstrassPoint) and isinstance(scalar, int), \
                'Can only multiply Point with a scalar.'
        scalar %= self.curve.q
        pow2 = self
        acc = self.curve.id
        while True:
            if scalar & 1:
                acc += pow2
            scalar >>= 1
            if scalar == 0: return acc
            pow2 += pow2
    
    def __rmul__(self, scalar):
       return self * scalar

def jacobi_symbol(n: int, p: int):
    assert n > 0 and p > 0, 'Parameters to Jacobi symbol must be positive!'
    assert p % 2, 'p must be odd.'
    sign = 1
    while True:
        if p == 1: return sign
        n %= p
        if n == 0: return 0
        even_invert = (p % 8) in (3, 5)
        while n & 1 == 0:
            if even_invert:
                sign = -sign
            n >>= 1
        if n == 1: return sign
        if n % 4 == 3 and p % 4 == 3:
            sign = -sign
        n, p = p, n

def sqrtmod(n: int, p: int) -> int:
    ''' Tonelli-Shanks algorithm '''
    # find q, s such that q2^s = p-1
    q = p-1
    s = 0
    while q & 1 == 0:
        s += 1
        q >>= 1
    # get a quadratic non-residue
    for z in range(1, p):
        if jacobi_symbol(z, p) == -1:
            break
    # let
    m = s
    c = pow(z, q, p)
    t = pow(n, q, p)
    r = pow(n, (q + 1) >> 1, p)
    # loop
    while True:
        if t == 0: return 0
        if t == 1: return r
        t2i = t
        for i in range(1, m):
            t2i = pow(t2i, 2, p)
            if t2i == 1: break
        else:
            return None
        b = pow(c, 1 << (m - i - 1), p)
        m = i
        c = pow(b, 2, p)
        t = (t * c) % p
        r = (r * b) % p

class MontgomeryCurve:
    def __init__(self, a, b, p):
        # b*v^2 = u^3 + a*u^2 + u
        self.a = a
        self.b = b
        self.p = p

def ladder(u: int, k: int, a: int, p: int) -> int:
    # calculate u * k, with u being the first coordinate and k a scalar
    u2, w2 = 1, 0
    u3, w3 = u, 1
    for i in reversed(range(p.bit_length())):
        b = 1 & (k >> i)
        if b: u2, u3, w2, w3 = u3, u2, w3, w2

        # don't compute this twice in the second line below
        u2u2, u2w2, w2w2 = u2 * u2, u2 * w2, w2 * w2
        u3, w3 = pow(u2 * u3 - w2 * w3, 2, p), (u * (u2 * w3 - w2 * u3) ** 2) % p
        u2, w2 = pow(u2u2 - w2w2, 2, p), (4 * u2w2 * (u2u2 + a * u2w2 + w2w2)) % p

        if b: u2, u3, w2, w3 = u3, u2, w3, w2
    
    if w2 == 0: return 0
    return (u2 * invmod_prime(w2, p)) % p